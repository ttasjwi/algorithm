# 문제
- 플랫폼 : 프로그래머스
- 번호 : 042584
- 제목 : 주식가격
- 난이도 : Level 2
- 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/42584" target="_blank">링크</a>

---

# 필요 지식
- 스택

---

# 풀이
```python
def solution(prices):
    answer = [0] * len(prices)

    stack = [] # (그 시점 시간, 그 시점 가격) 저장
    
    for t, price in enumerate(prices):
        # 스택 최상단에 위치한 가격이 현재 가격보다 비싸다는 것은, 현 시점에 가격이 떨어졌다는 뜻
        # 더 이상 스택에 보관할 가치가 없으므로 꺼내서, answer 를 갱신해준다. (가격이 떨어지기까지 시간 갱신) 
        while stack and stack[-1][1] > price:
            start_t = stack.pop()[0]
            answer[start_t] = t - start_t
        
        # 스택에 (현재 시각, 현재 가격) 을 삽입 ==> 이러면 스택에는 가격이 싼게 제일 아래, 가격이 제일 비싼게 제일 위에 쌓임
        stack.append((t, price))
    
    # 스택에 요소가 남아있다는 것은 끝까지 가격이 안 떨어졌다는 것을 의미 => 전부 꺼내서 answer 갱신
    while stack:
        start_t = stack.pop()[0]
        answer[start_t] = len(prices) - 1 - start_t
    return answer
```
- 요구사항 분석
  - 매 시간마다 시간, 가격은 변화한다.
- 풀이방법 설계
  1. 매 시간마다 prices 배열을 순회하면서 가격이 떨어졌는 지 확인하는 것은 시간복잡도가 O(N^2) 라서 시간 초과가 발생할 것으로 추정
  2. 시간이 경과하더라도, 가격이 떨어진 한번 떨어진 요소들은 더 이상 필요 없게 하는 것이 탐색시간을 줄일 수 있을 것 같다.
  3. 이 과정에서 스택/큐와 같은 자료구조를 사용하면 문제 풀이를 간소화할 수 있겠다는 생각이 1차적으로 들었음.
- 자료구조 선택
  - xxx 에는 매 초마다 그 시점의 (시간, 가격) 튜플을 저장해야한다.
  - xxx 에 저장한 튜플은 가격순으로 놓이게되며, 꺼낸 튜플은 그 xxx 에서 가장 가격이 비싸야함
  - xxx 에 저장한 튜플을 꺼냈을 때 가격이 현재 가격보다 비싸면 계속 저장할 가치가 없음(가격이 떨어졌으므로)
    - 이런 것들은, 전부 꺼내다가 answer 의 해당 시각 인덱스쪽에서, 몇 초만에 가격 하락이 있었는지 갱신해야함
  - 마지막에 놓인 요소가, 가장 가격이 비싼 (시간, 튜플) 이 되어야하고, 매번 이를 먼저 꺼내는 구조가 편리
  - xxx = 스택

---
